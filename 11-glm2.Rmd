

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(nnet)
library(MASS)
library(pscl)
library(knitr)
```

# その他のカウントデータの解析

※2020/11/04　執筆中  
前の章で，カウントデータの解析としてポアソン回帰を扱った。この章では，その他のカウントデータの解析法について説明する。  
  
* 負の二項回帰（過分散対策）  
* 順序ロジスティック回帰  
* 多項ロジスティック回帰   
* ゼロ過剰ポアソン回帰   
  
## 準備

tidyverseパッケージに加え，`MASS`，`nnet`パッケージを使う。  
`MASS`パッケージは負の二項分布を用いたモデルのときに，`nnet`パッケージは多項ロジスティック回帰のときに必要になる。初めて使う際には，事前にインストールが必要になる。


```{r, eval=FALSE}

library(tidyverse, MASS, nnet)

```



## 負の二項回帰

応答変数がカウントデータの場合，ポアソン回帰で分析する方法を前の章で学んだ。しかし，実際のデータは分散が平均よりも大きい場合が多く，平均と分散が等しい確率分布であるポアソン分布を用いると予測変数の効果を誤って判断してしまう恐れがある。これが，**過分散（overdispersion）**の問題である。  
  
過分散対策として，応答変数が従う分布をポアソン分布ではなく，**負の二項分布(negative binomial distribution)**を用いる方法がよく使われる。  
  
### 負の二項分布

例えばコインを投げて表が出る確率を0.5として，3回表が出るまで投げようと決めたとする。8回投げたところで3回出た場合，表が3回出る確率は以下から求めることができる。

```{r}

choose(8-1, 3-1)*0.5^2*(1-0.5)^(8-3)*0.5 #つまり，7回中表が2回，裏が5回出て，最後の１回で表が出る確率を求める。

```


これを一般化した式が以下である。成功確率を$q$として，$r$回成功するまでに試行が$x$回かかる確率を表した確率分布が，負の二項分布である。

$$
P(x) = {}_{x-1}\mathrm{C}_{r-1} q^{r}(1-q)^{x-r}
$$
失敗回数を$y$として，以下のように置き換えることもできる($x=y+r$を代入する)。$x$回目までに$r$回ある事象が生じる確率と言い換えることができる。

$$

P(y) = {}_{y+r-1}\mathrm{C}_{r-1} q^{r}(1-q)^{y}

$$

Rでも`nbinom`で負の二項分布の確率を計算することができる。

```{r}
x = 0:10
p_y = dbinom(x = x, size = 10 - 3, prob = 0.5)

d_plot = data.frame(x = x, p_y = p_y)

ggplot() + 
  geom_bar(data = d_plot, aes(x = x, y = p_y), stat = "identity") + 
  labs(x = "number of trials", y = "probability", title = "number of success = 3")

```


負の二項分布の期待値を$E(x)=\mu$とすると，分散は$Var(x)=\mu + \mu^{2}/r$で，分散が期待値（平均）よりも$\mu^{2}/r$大きい。負の二項分布によって，分散が平均よりも大きい分布を扱うことができる。   
  
  
### Rでの負の二項回帰


Rでは，`MASS`パッケージに含まれている`glm.nb()`関数で，負の二項回帰を扱うことができる。Rに入っている`warpbreaks`をサンプルデータとして，ポアソン回帰と負の二項回帰の結果を比較してみよう。

```{r}

d = warpbreaks #別の名前(d)で保存する
d$A <- ifelse(d$wool == "A", 1, 0) #Aなら1, Bなら0のダミー
head(d)

ggplot() + 
  geom_histogram(data = d, aes(x = breaks, fill = wool), binwidth = 1)

```

`breaks`に対する`wool`(A or B)の効果を検討する。まずは，ポアソン回帰の結果を見てみる。`breaks`を$y$，`A`を$x$とすると，モデルは以下のように表現できる。

$$

\lambda = \alpha + \beta x\\

y \sim Poisson(\lambda)

$$


```{r}
model_poisson = glm(data = d, breaks ~ A, family = poisson(link = "log"))
summary(model_poisson)

mean(d$breaks)
var(d$breaks)

```

`A`に係る傾きの推定値について，かなり小さいp値が推定されている。  

```{r, include = FALSE}

model_poisson$deviance/model_poisson$df.residual

```
  
次に，負の二項回帰の結果と比較してみよう。


$$

\mu = \alpha + \beta x\\

y \sim NegativeBinom(\mu, r)

$$


`MASS`パッケージの`glm.nb()`を使う。

```{r}

model_nb = MASS::glm.nb(data = d, breaks ~ A) #lm関数と同じ要領で，線形の式を入力する。確率分布はオプションで指定しないで良い。
summary(model_nb)

```

ポアソン回帰と比べると`A`のp値が大きくなり，過分散が解消されたことがうかがえる。


## 順序ロジスティック回帰

「優，良，可」といった成績や「1=当てはまらない，..., 5 = 当てはまる」といったリッカート尺度といった順序変数はカテゴリカル変数であるので，正規分布に従う前提を置くなど，量的変数のように扱うのは本来は適切といえない。二値のカテゴリカル変数の場合は二項分布を用いるロジスティック回帰で検討できたが，3つ以上のカテゴリを持つ変数の場合はどうすればよいか？  
  
応答変数が順序変数の場合は，**順序ロジスティック回帰(ordred logistic regression)**が使われる。  
  
### 順序ロジスティック回帰モデルの詳細

#### 累積確率と累積ロジット{-}

例えば，$y$を試験の成績を意味する順序変数として「1=不可，2=可，3=良，4=優，5=秀」の値を取るとする。この成績$y$に対して，試験前日の睡眠時間$x$が及ぼす影響を検討するとしよう。  

```{r, eval=FALSE}

#サンプルデータ



#各成績（不可，可，良，優，秀）の割合


```

順序のあるカテゴリカル変数を扱う場合には，累積確率（cumulative probability）で各変数が生じる確率を表現する。累積確率とは，順序変数のある値以下が生じる確率のことをいう。例えば，$y$が$k$以下の値を取る累積確率を$Pr(y≤k)$
と表現する。$Pr(y≤3)$は，$y$が1, 2, 3のいずれかが生じる確率を意味することになる。  カテゴリ$k$が生じる確率$p_{k}$とすると，$p_{3}$は累積確率$Pr(y≤3)$から累積確率$Pr(y≤2)$を引けば求められる。  
    
つまり，$p_{k}$は以下の式で表現することができる。

$$

p_{k}=Pr(y≤k)−Pr(y≤k−1)

$$

なお，カテゴリの最大値が出る確率は，全体の確率から引けば求まる。例えば，$p_{5}$は全体から累積確率$Pr(y≤5)-Pr(y≤4)$を計算しなくとも，$1-Pr(y≤5)$で求まる。

#### 線形予測子との関係 {-}

カテゴリ$k$が得られる累積確率$Pr(y ≤ k)$は，K-1個の切片$a_{k}$で示すことができる。

$$

Pr(y≤k) = \frac{\exp(\alpha_{k})}{1+\exp(\alpha_{k})}

$$


更に，この切片に予測変数の効果（傾き）を加えると，累積確率は以下のように表現できる。

$$
\eta = \beta x\\
Pr(y ≤ k) = \frac{\exp(\alpha_{k} - \eta))}{1+\exp(\alpha_{k} - \eta)}

$$

各切片から傾きの効果を引いているところに注意。引くことによって，予測変数の値が大きいほど，累積確率の値が低くなる。言い換えれば，Pr(y>k)が大きくなる。つまり，予測変数の値が大きくなるほど，より大きい値のカテゴリが生じる確率が大きくなることを表現できる。  
  
カテゴリkの切片$a_{k}$と傾き$\beta$から，それぞれのカテゴリが生じる確率$p_{k}$を推定し，成績が確率のベクトルpをパラメータとするカテゴリカル分布にしたがって生成されるとする。

$$

p = (p_{1}, p_{2}, p_{3}, p_{4}, p_{5})\\

y \sim Categorical(p)

$$
  
  
  

### Rでの順序ロジスティック回帰


Rで順序尺度を扱う場合は，変数を順序付きの因子型(factor)変数にする必要がある。
`factor()`もしくは`ordered()`を使って作成する。

```{r, eval=FALSE}

dat$rating = factor(dat$rating, levels = c("1", "2", "3", "4", "5"), ordered = TRUE)
dat$rating = ordered(dat$rating, levels = c("1", "2", "3", "4", "5"))
#levelsで，水準の順序を指定する
#factor()では，オプションoredered=TRUEを加える

```


`MASS`パッケージに含まれている，`polr()`を使う。`lm()`と同じ要領で，応答変数~予測変数のモデルを書けば結果を出力してくれる。

```{r, eval=FALSE}
model_polr  = MASS::polr(data = dat, rating ~ contact_dum + temp_dum)
summary(model_polr)

```

`Coefficients`に予測変数に係る傾きの係数の推定値，`Threshold coefficients`に$K-1$個の切片の推定値が表示されている。

p値は出力してくれないので，自分で計算する必要がある。t値をもとに，以下のプログラムで計算する。

```{r, eval=FALSE}

#p値の出力
z = summary(result_mnl)$coefficients/summary(result_mnl)$standard.errors
p = (1 - pnorm(abs(z), mean = 0, sd = 1)) * 2
p


ctable = coef(summary(model_polr))
p = pnorm(abs(ctable[,"t value"]), lower.tail = FALSE)*2
(cbind(ctable, "p value" = p))

```


## 多項ロジスティック回帰

応答変数が3つ以上のカテゴリの名義尺度（順序関係がない）場合は，どのようなモデルが適切だろうか？例えば，サイコロの目それぞれが出る確率を推定する場合である。


### Rでの多項ロジスティック回帰

例えば，多項ロジスティック回帰を行うことのできるパッケージとして，`nnet`パッケージの`multinom()`関数がある。`lm()`と同じ要領でモデルを記述すると，推定結果を出力してくれる。

```{r, eval=FALSE}
library(nnet)

result_mnl <- nnet::multinom(data = mlogit_sampledata, MyDice_2 ~ FinalProfit)
summary(result_mnl)


```


```{r, eval=FALSE}

#p値の出力
z = summary(result_mnl)$coefficients/summary(result_mnl)$standard.errors
p = (1 - pnorm(abs(z), mean = 0, sd = 1)) * 2
p

```


## ゼロ過剰ポアソン回帰


### Rでのゼロ過剰ポアソン回帰

`pscl`パッケージの`zeroinfl()`関数がある。`lm()`と同じ要領でモデルを記述すると，推定結果を出力してくれる。


```{r}

head(bioChemists)

ggplot() + 
  geom_histogram(data = bioChemists, aes(x=art), binwidth = 1, fill="white", color="black")
table(bioChemists$art)


model_zeroinfl = pscl::zeroinfl(data = bioChemists, art ~ fem + mar + kid5 + phd + ment)
summary(model_zeroinfl)

```




```{r, eval=FALSE}

#確認問題
#MASSのhousingを使う
str(housing)
d = housing
d$ID = 1:nrow(d)

mean(d$Freq)
var(d$Freq)

ggplot() + 
  geom_histogram(data = d, aes(x = Freq), binwidth = 1)

summary(glm(data = d, Freq ~ Cont, family = poisson(link = "log")))
summary(glm.nb(data = d, Freq ~ Cont))
summary(glmer(data = d, Freq ~ Cont + (1|ID), family=poisson))

```
